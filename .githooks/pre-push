#!/usr/bin/env bash
# pre-push hook: ensure CHANGELOG.md has been updated on branch pushes (PRs)
#
# It inspects the set of commits being pushed for each ref and verifies that
# CHANGELOG.md is among the changed files. The check is applied to branch pushes
# (refs/heads/*) except for main/master. Tag pushes and pushes to main/master are
# exempt. You can bypass the check by setting BYPASS_CHANGELOG_CHECK=1.
#
# Additionally, this hook validates that CHANGELOG.md follows Keep a Changelog
# conventions and that the reference links at the bottom match the headings.

set -euo pipefail

if [[ "${BYPASS_CHANGELOG_CHECK:-}" == "1" ]]; then
  echo "[pre-push] Bypassing CHANGELOG check due to BYPASS_CHANGELOG_CHECK=1"
  exit 0
fi

remote_name="$1"; shift || true
# Discard remote URL argument (intentionally unused)
shift || true

# Read lines from stdin: local_ref local_sha remote_ref remote_sha

missing_changelog=0
# Track whether this push includes any branch refs (refs/heads/*). When only tags
# are being pushed (e.g., release pipeline pushing a tag), we will skip the
# svu/CHANGELOG next-version verification.
saw_branch_push=0
# local_ref is intentionally unused; prefix with underscore to avoid unused warnings
while read -r _local_ref local_sha remote_ref remote_sha; do
  # Skip if nothing to push for this ref
  if [[ "$local_sha" == "0000000000000000000000000000000000000000" ]]; then
    continue
  fi

  # Only enforce on branch pushes (potential PRs), skip tags
  if [[ "$remote_ref" != refs/heads/* && "$remote_ref" == refs/tags/* ]]; then
    continue
  fi

  # Remember if we saw a branch push in this batch
  if [[ "$remote_ref" == refs/heads/* ]]; then
    saw_branch_push=1
  fi

  # Skip protected default branches
  if [[ "$remote_ref" == "refs/heads/main" || "$remote_ref" == "refs/heads/master" ]]; then
    continue
  fi

  # Determine the base for diff: if remote ref doesn't exist yet (new branch),
  # use the merge-base with default branch if available; else use remote_sha.
  base="$remote_sha"
  if [[ "$remote_sha" == "0000000000000000000000000000000000000000" ]]; then
    # Attempt to find default branch (main or master)
    default_branch=""
    if git show-ref --verify --quiet refs/remotes/${remote_name}/main; then
      default_branch="refs/remotes/${remote_name}/main"
    elif git show-ref --verify --quiet refs/remotes/${remote_name}/master; then
      default_branch="refs/remotes/${remote_name}/master"
    fi

    if [[ -n "$default_branch" ]]; then
      if base_commit=$(git merge-base "$local_sha" "$default_branch" 2>/dev/null); then
        base="$base_commit"
      else
        base=""
      fi
    else
      base=""
    fi
  fi

  # Compute changed files
  if [[ -n "$base" ]]; then
    changed_files=$(git diff --name-only "$base" "$local_sha")
  else
    # Fallback: use the files in the commits reachable from local that aren't in any remote
    changed_files=$(git diff --name-only "$local_sha^!" || true)
  fi

  if [[ -z "$changed_files" ]]; then
    # Nothing changed? Be conservative and fail so contributor reviews message.
    missing_changelog=1
    continue
  fi

  if ! grep -qx "CHANGELOG.md" <<<"$changed_files"; then
    echo "[pre-push] Missing CHANGELOG.md update for push to $remote_ref" >&2
    echo "[pre-push] The commits you are pushing must include a change to CHANGELOG.md." >&2
    echo "[pre-push] If this push is not part of a PR or should be exempt, set BYPASS_CHANGELOG_CHECK=1." >&2
    missing_changelog=1
  fi

done

# Validate CHANGELOG formatting and link references regardless of whether it changed
validate_changelog() {
  local file="CHANGELOG.md"
  if [[ ! -f "$file" ]]; then
    echo "[pre-push] ERROR: $file not found in repository root." >&2
    return 1
  fi

  local errors=0

  # Ensure top-level title exists
  if ! grep -Eq '^# Changelog\s*$' "$file"; then
    echo "[pre-push] ERROR: CHANGELOG.md must start with '# Changelog' title." >&2
    errors=1
  fi

  # Find headings and validate date format for released versions
  # Capture line num and content to point out problems
  while IFS= read -r line; do
    local lineno=${line%%:*}
    local content=${line#*:}
    # Extract name inside brackets
    local name
    name=$(sed -E 's/.*\[([^]]+)\].*/\1/' <<<"$content")
    if [[ "$name" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      if ! grep -Eq "^## \[$name\] - [0-9]{4}-[0-9]{2}-[0-9]{2}$" <(printf '%s' "$content"); then
        echo "[pre-push] ERROR: Line $lineno: Release '$name' must include a date 'YYYY-MM-DD' (Keep a Changelog)." >&2
        errors=1
      fi
    fi
  done < <(grep -En '^## \[(Unreleased|[0-9]+\.[0-9]+\.[0-9]+)\]( - [0-9]{4}-[0-9]{2}-[0-9]{2})?$' "$file")

  # Build sets of heading names and link reference names (compatible with macOS bash 3.2)
  local headings links name saved_ifs
  headings=$(grep -En '^## \[(Unreleased|[0-9]+\.[0-9]+\.[0-9]+)\]' "$file" | sed -E 's/.*\[([^]]+)\].*/\1/' | sed -E 's/^Unreleased$/unreleased/I' | sort -u)
  links=$(grep -En '^\[([0-9]+\.[0-9]+\.[0-9]+|[Uu]nreleased)\]:' "$file" | sed -E 's/.*\[([^]]+)\].*/\1/' | sed -E 's/^Unreleased$/unreleased/I' | sort -u)

  contains() { grep -Fxq "$1" <<<"$2"; }

  # Check each heading has a link
  if [[ -n "$headings" ]]; then
    saved_ifs="$IFS"; IFS=$'\n'
    for name in $headings; do
      if ! contains "$name" "$links"; then
        # Allow that Unreleased heading may not have a link if there are no releases
        if [[ "$name" != "unreleased" ]]; then
          echo "[pre-push] ERROR: Missing link reference for heading '[$name]' at bottom of CHANGELOG.md." >&2
          errors=1
        fi
      fi
    done
    IFS="$saved_ifs"
  fi

  # Check there are no extra links without headings
  if [[ -n "$links" ]]; then
    saved_ifs="$IFS"; IFS=$'\n'
    for name in $links; do
      if ! contains "$name" "$headings"; then
        echo "[pre-push] ERROR: Link reference '[$name]:' exists without a corresponding '## [$name]' heading." >&2
        errors=1
      fi
    done
    IFS="$saved_ifs"
  fi

  if [[ $errors -ne 0 ]]; then
    cat >&2 <<'EOM'
[pre-push] Hints:
- Follow https://keepachangelog.com/en/1.1.0/
- Each release heading must be in the form: '## [X.Y.Y] - YYYY-MM-DD'
- Include '## [Unreleased]' at the top.
- Add link reference definitions at the bottom for each heading, e.g.:
  [unreleased]: https://github.com/<org>/<repo>/compare/vX.Y.Z...HEAD
  [X.Y.Z]: https://github.com/<org>/<repo>/compare/vA.B.C...vX.Y.Z
EOM
    return 1
  fi

  return 0
}

if ! validate_changelog; then
  echo "[pre-push] Push aborted due to CHANGELOG.md validation errors." >&2
  exit 1
fi

if [[ "$missing_changelog" -ne 0 ]]; then
  echo "[pre-push] Push aborted due to missing CHANGELOG.md update." >&2
  exit 1
fi

# Compute the next version using svu and ensure it's present in CHANGELOG.md
verify_next_version_in_changelog() {
  local file="CHANGELOG.md"
  if [[ ! -f "$file" ]]; then
    echo "[pre-push] ERROR: $file not found in repository root." >&2
    return 1
  fi

  # Try to locate svu in PATH first
  local svu_bin="svu"
  if ! command -v "$svu_bin" >/dev/null 2>&1; then
    # Fallback to $(go env GOBIN)/svu or $(go env GOPATH)/bin/svu if available
    if command -v go >/dev/null 2>&1; then
      local gobin
      gobin=$(go env GOBIN 2>/dev/null || true)
      if [[ -n "$gobin" && -x "$gobin/svu" ]]; then
        svu_bin="$gobin/svu"
      else
        local gopath
        gopath=$(go env GOPATH 2>/dev/null || true)
        if [[ -n "$gopath" && -x "$gopath/bin/svu" ]]; then
          svu_bin="$gopath/bin/svu"
        fi
      fi
    fi
  fi

  if ! command -v "$svu_bin" >/dev/null 2>&1; then
    echo "[pre-push] ERROR: 'svu' is required for CHANGELOG validation but was not found in PATH." >&2
    echo "[pre-push] Hint: Install svu (e.g., with Homebrew: 'brew install svu') or ensure it is on your PATH." >&2
    return 1
  fi

  # Run svu to compute the next version. It typically returns a 'vX.Y.Z' tag.
  local next_tag next_version
  if ! next_tag=$("$svu_bin" next --force-patch-increment 2>/dev/null); then
    echo "[pre-push] ERROR: Failed to execute '$svu_bin next --force-patch-increment'." >&2
    return 1
  fi
  next_tag=$(printf "%s" "$next_tag" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')
  if [[ -z "$next_tag" ]]; then
    echo "[pre-push] ERROR: svu returned an empty version." >&2
    return 1
  fi

  # Strip a leading 'v' to match CHANGELOG headings format [X.Y.Z]
  next_version=${next_tag#v}

  # Check for heading presence: ## [X.Y.Z] - YYYY-MM-DD
  if ! grep -Eq "^## \[$next_version\] - [0-9]{4}-[0-9]{2}-[0-9]{2}$" "$file"; then
    echo "[pre-push] ERROR: CHANGELOG.md is missing a release heading for version [$next_version]." >&2
    echo "[pre-push] Hint: Add a section like '## [$next_version] - YYYY-MM-DD' and move entries from Unreleased." >&2
    return 1
  fi

  # Check for link reference presence: [X.Y.Z]: https://...
  if ! grep -Eq "^\[$next_version\]:\s+https?://" "$file"; then
    echo "[pre-push] ERROR: CHANGELOG.md is missing the link reference definition for [$next_version]:" >&2
    echo "[pre-push] Hint: Add a line near the bottom, e.g.:" >&2
    echo "[pre-push]   [$next_version]: https://github.com/<org>/<repo>/compare/vA.B.C...v$next_version" >&2
    return 1
  fi

  return 0
}

# Skip next-version verification in release/CI pipelines and on tag-only pushes
# Conditions to skip:
# - Explicit opt-out via SKIP_SVU_CHANGELOG_CHECK=1
# - GoReleaser environment variables are present (GORELEASER or GORELEASER_CURRENT_TAG)
# - No branch refs were part of this push (i.e., tag-only push)
if [[ "${SKIP_SVU_CHANGELOG_CHECK:-}" == "1" || -n "${GORELEASER_CURRENT_TAG:-}" || -n "${GORELEASER:-}" || "$saw_branch_push" -eq 0 ]]; then
  echo "[pre-push] Skipping svu next-version check (release/tag-only/opt-out)."
else
  if ! verify_next_version_in_changelog; then
    echo "[pre-push] Push aborted: CHANGELOG.md does not include the next version from svu." >&2
    exit 1
  fi
fi

exit 0
